'''题目1：一维布尔索引
创建 a = np.arange(20)，完成：
取出所有大于 10 的元素。
取出所有奇数。
把小于 5 的元素改成 100。
题目2：组合条件
创建 b = np.arange(30)，完成：
取出 10 < b < 20 的元素。
取出能被 4 整除 或 大于 25 的元素。
把 b < 5 或 b > 25 的元素改成 -1。
题目3：二维布尔索引
创建 m = np.arange(1, 17).reshape(4, 4)，完成：
取出所有偶数。
把大于 10 的元素替换为 0。
取出能被 3 整除的元素。
题目4（加分）
解释为什么布尔索引通常比 for 循环更快？'''
import numpy as np
print(f"————————————————————————————题目1开始————————————————————————————")
# 题目1
a1=np.arange(20)
a1_mask=a1>10
# 取出大于10的元素
print(f"题目1：取出a1中大于10的元素的结果是\n{a1_mask}\n对应的值为\n{a1[a1_mask]}")
b1=(a1%2==1)
# 取出奇数
print(f"题目1：取出a1中奇数元素的结果是\n{b1}\n对应的值为\n{a1[b1]}")
a1[a1<5]=100
# 把小于5的元素改为100
print(f"题目1：把a1中小于5的元素改为100的结果是\n{a1}")
print(f"————————————————————————————题目1结束————————————————————————————")
print(f"————————————————————————————题目2开始————————————————————————————")
a2=np.arange(30)
b2=a2[(a2>10)&(a2<20)]
# 取出 10 < b < 20 的元素
print(f"题目2：取出 10 < b < 20 的元素结果对应的值是\n{b2}")
c2=a2[(a2%4==0)|(a2>25)]
# 取出能被 4 整除 或 大于 25 的元素。
print(f"题目2：取出能被 4 整除 或 大于 25 的元素结果是\n{c2}")
a2[(a2<5)|(a2>25)]=-1
# 把 b < 5 或 b > 25 的元素改成 -1
print(f"题目2：把 b < 5 或 b > 25 的元素改成 -1结果是\n{a2}")
print(f"————————————————————————————题目2结束————————————————————————————")
print(f"————————————————————————————题目3开始————————————————————————————")
a3 = np.arange(1, 17).reshape(4, 4)
print(f"题目3：初始矩阵为\n{a3}")
b3=a3[a3%2==0]
# 取出所有偶数
print(f"题目3：取出所有偶数为\n{b3}")
a3[a3>10]=0
# 把大于 10 的元素替换为 0
print(f"题目3：把大于 10 的元素替换为 0为\n{a3}")
c3=a3[(a3%3==0)]
# 取出能被 3 整除的元素
print(f"题目3：取出能被 3 整除的元素为\n{c3}")
print(f"————————————————————————————题目3结束————————————————————————————")
# 题目4：布尔索引通过底层编译优化、高效的向量化操作、缓存友好的内存访问以及潜在的并行计算，实现了比 Python for循环高得多的执行效率。其本质是用高度优化的编译代码批量处理数据，替代了依赖解释器逐个处理且开销较大的循环。





# 你现在的写法：
#
# ```python
# a3[a3 > 10] = 0   # 直接修改了 a3 本身
# ```
#
# 会 **在原地** 把 `a3` 中大于 10 的元素改成 0。
#
# ---
#
# ## 📌 如果想保留原始矩阵，有两种写法：
#
# ### 方法1：先复制再修改
#
# ```python
# import numpy as np
# a3 = np.arange(1, 17).reshape(4, 4)
#
# b3 = a3.copy()        # 复制一个新矩阵
# b3[b3 > 10] = 0       # 在副本上修改
# print("原始矩阵 a3:\n", a3)
# print("修改后的 b3:\n", b3)
# ```
#
# 这样 `a3` 不会变，`b3` 是修改后的结果。
#
# ---
#
# ### 方法2：生成新矩阵（不修改原地）
#
# 直接用 `np.where`：
#
# ```python
# a3 = np.arange(1, 17).reshape(4, 4)
#
b3 = np.where(a3 > 10, 0, a3)   # 条件为真 → 0，否则保留原值
# print("原始矩阵 a3:\n", a3)
# print("新矩阵 b3:\n", b3)
# ```
#
# `np.where` 的好处是 **一步生成新矩阵**，不会动原始的。
#
# ---
#
# ## 🎯 总结
#
# * **想要修改原地**：直接写 `a3[a3>10] = 0`。
# * **想要生成新矩阵**：用 `.copy()` 或 `np.where`。


